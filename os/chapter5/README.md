# <u>CPU 스케줄링</u>

- 버스트란 특정 기준에 따라 한 단위로서 취급되는 연속된 신호나 데이터의 모임을 말한다. 즉, 입출력 요청을 위해 CPU 사용을 사용했다가 쉬었다가를 반복한다.
- 프로세스가 CPU를 사용할 때를 CPU버스트, 입/출력을 기다릴 때를 입/출력 버스트라고 한다.
- 프로세스의 실행은 CPU 버스트를 시작으로 뒤이어 입출력 버스트가 발생하는 식으로 두 <b>버스트</b>의 사이클로 구성된다.

---

***선점과 비선점 스케줄링***

1.Preemptive Scheduling(선점 스케줄링)

- 수행되고 있는 프로세서의 권한을 가지고 올 수 있다.
- 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용한다.
- 선점으로 인해 많은 오버헤드를 초래할 수 있다.
- 선점을 위해 인터럽트 타이머 클럭이 필요하다.
- 종류 : 선점 우선순위, RR(Round Robin), 다단계 큐, 다단계 피드백 큐 알고리즘 등

2.non-Preemptive Scheduling(비선점 스케줄링)

- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없다.
- 한 프로세스가 실행 상태에서 대기 상태로 전환될 때, 프로세스가 종료할 때 비선점 스케줄링을 사용한다.
- 응답시간 예측이 쉽다.
- 협조적(cooperative)이며 모든 프로세스를 공정하게 처리한다.
- 종류 : FCFS, SJF, 우선순위, HRN, 기한부 알고리즘 등

---

***Dispatcher(디스패처)***

CPU의 제어를 단기 스케줄러가 선택한 프로세스에게 주는 모듈이다. 즉, ready에서 running으로 넘어갈 때 스케줄러에 의해 선택되는 것을 말한다.

- context switch가 일어나는 일
- 사용자 모드로 전환하는 일
- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일

디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는 데까지 소요되는 시간을 dispatch latency(디스패치 지연)라고 한다. 이는 ready queue에서 running queue로 넘어갈
때 PCB에 복사해 주는 시간을 말하며, 시스템 효율을 결정한다.

---
***스케줄링 기준(Scheduling Criteria)***(중국집 주방장을 예로들자 주방장 -> CPU)

1. utilization(CPU 이용률) : CPU를 최대한 바쁘게 유지하는 것이 좋다.

2.throughput(처리량) : 단위 시간 당 완료된 프로세스의 개수를 말한다.

3.turnaround time(총 처리 시간) : 프로세스를 실행하는 데 소요된 시간을 말한다. 프로세스의 제출 시간과 완료 시간의 간격을 말한다.

4.waiting time(대기시간) : 프로세스가 ready/waiting queue에서 대기하는 시간을 말한다.

5.response time(응답시간) : 응답이 시작되는 데까지 걸리는 시간을 말한다. 처음 반응한 시간을 말한다. <b>
turnaround time</b>(총 처리 시간) - running에 있는 시간 = waiting time(대기 시간)

---

***스케줄링 알고리즘(Scheduling Algorithms)***

- FCFS (First Come First Served) 스케줄링
    - 가장 먼저 요청한 프로세스에 CPU를 할당해주는 방식이다.
    - 비선점형(Non-preemptive) 스케줄링이다.
    - 작성이 간단하고 이해하기 쉽다.
    - Convoy Effect(호위 효과)가 발생할 수 있다. 콘보이 이펙트란 -> CPU 사용시간이 긴 프로세스에 의해 사용시간이 짧은 프로세스들이 오래 기다리는 현상으로 ＂호위 효과 ” 라고도 하며, 이로
      인해 평균 대기시간이 길어지게 되는것을 말한다.
- SJF(Shortest-Job-First) 스케줄링
    - 다음 CPU burst time의 길이를 고려해서 스케줄링을 결정하는 알고리즘이다
    - SJF 스케줄링은 평균 대기 시간을 줄일 수 있다.
    - 다음 프로세스의 CPU burst time을 예측하는 것이 어렵다는 문제가 존재한다.
- Priority 스케줄링
    - 각각의 프로세스에 우선순위 넘버가 있다.
    - -가장 높은 우선순위의 프로세스에 CPU를 할당한다.
    - 기아(Starvation) 문제가 발생할 수 있다. 기아 문제란 낮은 우선순위의 프로세스가 절대 실행되지 않는 문제를 뜻함.
    - 기아문제를 해결하기 위해서 노화(aging)를 사용할 수 있다. 시간이 지날수록 프로세스의 우선순위를 높여주는 식.
- Round Robin(RR) 스케줄링
    - 각각의 프로세스에 동일한 CPU <u>할당 시간</u>(타임 퀀텀)을 부여해서 해당 시간 동안만 CPU를 이용하게 한다.
    - 할당 시간 내에 처리를 완료하지 못하면 다음 프로세스로 넘어가므로 선점형 방식이다.
- 다단계 큐 (Multilevel-Queue) 스케줄링
    - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 Queue를 사용한다.(신분 이동 x)
- 다단계 피드백  (Multilevel-Feedback-Queue) 스케줄링
    - 다단계 큐에서 자신에게 할당된 Time Quantum을 다 사용한 프로세스는 밑으로 내려가고 Time Quantum을 다 채우지 못한 프로세스는 원래 큐 위치 그대로 둔다.(신분 상하승)

---

***다중 처리기(Multiple Processor Scheduling)***

뜻 -> 여러 개의 CPU가 있는 다중 처리기 시스템 스케줄링

1. 비대칭 다중 처리 (Asymmetric Multiprocessing)
    - 오직 하나의 코어만 시스템 자료구조에 접근한다.
        - 하나의 처리기만 시스템 자료구조에 접근하여 처리기 간의 자료들을 공유할 필요 없다. 단점 -> master server가 전체 시스템 성능을 저하할 수 있는 병목 발생할 수 있다.


2. 대칭 다중 처리 (Symmetric Multiprocessing : SMP)
    - 각 처리기(Processor)가 독자적인 스케줄링을 수행하는 방식
        - 다중 처리기를 지원하기 위한 표준 접근 방식 각 Processor는 스스로 스케줄링할 수 있다.
        - 스케줄 대상이 되는 스레드를 관리하기 위한 두 가지 가능한 전략
            - 모든 스레드가 공통 준비 큐에 있을 수 있다. (common ready queue)
            - 각 프로세서는 자신만의 스레드 큐를 가질 수 있다. (per-core run queues)


3. 부하 균등화 (Load Balancing)
    - 부하가 각 처리기에서 균등하도록 배분하는 시스템 Processor가 하나 이상이라는 것을 최대한 활용하려면, 부하를 모든 처리기에 균등하게 배분하는 것이 중요하다. push migration과 pull
      migration은 서로 상호 배타적인 것이 아니다. 실제로 병렬적으로 구현된다.
        - (1) push migration : 특정 작업이 주기적으로 각 처리기의 부하를 검사하고 만일 불균형 상태로 밝혀지면 과부하인 처리기에서 상대적으로 덜 바쁜 처리기로 프로세스를 이동시킨다. (
          push)
        - (2) pull migration : 쉬고 있는 처리기가 바쁜 처리기의 처리를 기다리고 있는 프로세스를 가져온다. (pull)

